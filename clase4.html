<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Fundamentos contenedores Docker - CFL 410 - Clase 4</title>
		<!-- <link rel="icon" type="image/x-icon" href="/img/logos/IDEPInformaticaLogo.png"> -->
        <link rel="icon" type="image/x-icon" href="/img/logos/page.png">

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
		<!-- Custom CSS -->
		<link rel="stylesheet" href="css/egg.css">

        <!-- CLASE AUN NO DISPONIBLE-->
        <!-- <meta http-equiv="refresh" content="0; url=./404.html"> -->
		
	</head>
	<body>

        <!-- CLASE AUN NO DISPONIBLE-->
        <!-- <script>
            window.location.href = "/404.html";
        </script> -->

		<div class="reveal">
			<div class="slides">

            <section>

                <section id="inicio" data-state="customevent" data-transition="slide" data-background-gradient="radial-gradient(#ffffff, #dcffdc)" data-background-size="contain">
                    
                    <h3>Fundamentos y usos prácticos de Docker</h3>
                    <h4>Clase 4 : Redes y persistencia de datos</h4>

                </section>

                <section id="index" data-state="no_footer">
                    <h3>Temas de clase 4:</h3>
                    <h4>Redes</h4>
                    <small>
                        <ul>
                            <li><a href="#/networking_1">Redes en Docker</a></li>
                            <li><a href="#/net_bridge">Redes bridge</a></li>
                            <li><a href="#/net_bridge1">Puertos y redirecciones</a></li>
                            <li><a href="#/gestion_network1">Gestión de redes</a></li>

                        </ul>

                    </small>

                    <p>

                    <h4>Persistencia de datos</h4>
                    <small>
                        <ul>
                            <li><a href="#/intro_mounts">Administrar datos en Docker</a></li>
                            <li><a href="#/mounts_types">Tipos de montaje</a></li>
                            <li><a href="#/volumes">Volumenes</a></li>
                            <li><a href="#/bind_mounts">Bind mounts</a></li>
                            <li><a href="#/volumenes">Gestión de volumenes</a></li>                      
                        </ul>
                    
                    </p>
                    <a href="#/labs_clase">Laboratorios</a>
                    <p><a href="?print-pdf">Exportar clase</a></p>
                </small>
                    
                </section>

            </section>
			

			<section>
				<section id="networking" data-state="customevent" data-transition="slide" data-background-gradient="radial-gradient(#ffffff, #dcffdc)" data-background-size="contain">
					<h3>Introducción a redes en Docker</h3>
                    
				</section>

				<section id="networking_1" data-state="no_footer">
					<h3>Redes en Docker</h3>
					
                    <small>
                    <p>Docker proporciona un sistema de redes virtuales que permite conectar contenedores entre sí, al host, y con el mundo exterior. Al utilizar Docker, es esencial comprender cómo funcionan las redes dentro de su ecosistema, ya que esto impacta directamente en la conectividad, la seguridad, y el comportamiento de las aplicaciones distribuidas.</p>
                   
                    <img src="img/clase4/network1.png" width="90%">
                    
                    
                    <p><a href="https://docs.docker.com/engine/network/" target="_blank">Docker Docs: Networking Overview</a> </p>
                    </small>

				</section>

                

                <section id="dockerfile_proposito" data-state="no_footer">
                    <h3>Network Drivers</h3>
                    <small>
                        <p>El subsistema de redes de Docker utiliza un conjunto de <em>drivers</em> para proveer de conectividad a los contenedores. Los drivers son:</p>
                    <ul>
                        <li>Bridge</li>
                        <li>Host</li>
                        <li>Null/None</li>
                        <li>Overlay</li>
                        <li>IPvlan</li>
                        <li>Macvlan</li>
                    </ul>
                    
                    </small>
                    <p><small>Se detallarán a continuación</small></p>
                    <small><p><a href="https://docs.docker.com/engine/network/drivers/" target="_blank">Docker Docs: Network Drivers</a></p></small>
                </section>

                <section id="net_bridge" data-state="no_footer">
					<h3>Redes Bridge</h3>

                    <small>
                         Actúa como un switch virtual dentro del host y permite la comunicación entre los contenedores que están en la misma red bridge a su vez que provee aislamiento a los contenedores que están en redes bridge separadas. La red bridge por defecto arranca en <strong>172.17.0.0/16</strong> y a medida que se van creando redes <em>bridge</em> va cambiando la red incrementando el segundo octeto <strong>172.x.0.0/16</strong>
                       
                    </small>

                    <img src="./img/clase4/bridge.png">

                    <small><a href="https://docs.docker.com/engine/network/drivers/bridge/" target="_blank">Docker Docs: Bridge network driver</a></small>

                    
                    

				</section>

                <section id="net_bridge0" data-state="no_footer">

                    <h3>Redes bridge</h3>
                    <small>
                        Además de las redes "del tipo" <em>bridge</em> existe una red ya creada homónima llamada <em>bridge</em>. Es la red por defecto que Docker crea en un host cuando se instala. Los contenedores que se inician sin especificar una red se conectan automáticamente a esta red.

                    </small>
                </section>

                <section id="net_bridge1" data-state="no_footer">
                    <h3>Puertos y redirecciones</h3>
                    <small>
                        <p>Los puertos son esenciales para permitir que los contenedores interactúen con el mundo exterior o con otros contenedores. Cuando un contenedor se ejecuta, puede exponer ciertos puertos para que otros servicios puedan comunicarse con él. Sin embargo, exponer un puerto del contenedor no lo hace automáticamente accesible desde fuera del host y es necesario <strong>publicar</strong> el puerto para que sea accesible.</p>
                        <p>Para publicar el puerto se hace con <code>-p P_HOST:P_CONTAINER</code></p>
                        <!-- <code><strong>docker run -p 8080:80 nginx</strong></code> -->
                    </small>
                        <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                            docker run -d -p 8080:80 docker/welcome-to-docker
                        </code></pre>
                    <small>
                        <p>Estas redirecciones se utilizan principalmente cuando estamos trabajando sobre redes <strong>bridge</strong>.</p>

                        <a href="https://docs.docker.com/get-started/docker-concepts/running-containers/publishing-ports/" target="_blank">Docker docs: Publishing and exposing ports</a>

                        
                    </small>

                </section>

                <section id="net_bridge2" data-state="no_footer">
                    <h3>Custom bridge vs default bridge</h3>
                    
                    <small>
                        <p>Al iniciar Docker, se crea una red predeterminada utilizando el driver bridge, denominada simplemente <strong>bridge</strong>. Todos los contenedores se conectarán a esta red de manera predeterminada, a menos que se especifique otra red al momento de su creación.</p>

                        <p>Es posible también crear nuestras propias redes del tipo <strong>bridge</strong>, conocidas como "User-defined bridge" o "custom bridge". Estas redes ofrecen capacidades superiores, como la inclusión de un <strong>DNS interno</strong> automático que permite <em>resolver la IP interna de un contenedor</em> utilizando su nombre.</p>
                    </small>

                    <!-- <pre class="codigo_shadow" data-id="code-animation"><code class="Dockerfile codigo-redondo" data-trim>
                        docker network ls
                        
                        NETWORK ID     NAME      DRIVER    SCOPE
                        cfd3f0bf25fc   bridge    bridge    local
                        abd3e7e42462   host      host      local
                        c1d27506736c   none      null      local
                    </code></pre> -->

                    <small>
                    <p>
                        
                            <a href="https://docs.docker.com/engine/network/drivers/bridge/#differences-between-user-defined-bridges-and-the-default-bridge" target="_blank">Docker docs: Differences between user-defined bridges and the default bridge</a>
                        
                        </p>
                    </small>


                



                </section>

                <section id="net_host1" data-state="no_footer">
                    <h3>Redes Host</h3>

                    <small>Con esta red, el contenedor comparte la pila de red del host, es decir, los servicios que se ejecutan en el contenedor escucharán en la misma dirección IP que el host.</small>
                    <small>Los contenedores que ejecuten este driver no tendrán direcciones IP propias y los puertos estarán mapeados 1:1 con los puertos de escucha del host.

                    <img src="./img/clase4/host.png">
                    
                    </small>
                    
                </section>



                <section id="net_host2" data-state="no_footer">
                    <h3>Redes Host</h3>
                    <small>
                        <p>En este driver, no hace falta publicar los puertos del contenedor, ya que se abrirán los mismos puertos de escucha del contenedor al host. Esto se debe a que no requiere traducción de direcciones de red (NAT) y no se crea ningún "proxy de usuario" para cada puerto.</p>
                        <p> Por lo general, es util en los siguientes casos:</p>
                            <ul>
                                <li>Optimizar la performance de red</li>
                                <li>El contenedor necesita manegar un rango de puertos amplio</li>
                            </ul>

                            <p>El driver Host está solo disponible en Docker Engine (Solo en hosts Linux) y en Docker Desktop a partir de la versión 4.34.</p>


        
                            <p><a href="https://docs.docker.com/engine/network/drivers/host/" target="_blank">Docker Docs: Driver Host</a></p>


                    </small>

                </section>

                <section id="net_none" data-state="no_footer">
                    <h3>Redes NONE/Null</h3>
                    <small>
                        <p>Este tipo de red deshabilita todas las capacidades de red del contenedor. Útil en casos donde se necesita un entorno de ejecución totalmente aislado sin acceso a la red.</p>
                    </small>

                    <img src="img/clase4/none.png">

                    <br>

                    <small>
                        <p><a href="https://docs.docker.com/engine/network/drivers/none/" target="_blank">Docker Docs: Driver None</a></p>
                    </small>

                    

                </section>

                <section id="net_ipvlan" data-state="no_footer">

                    <h3>Redes IPvlan</h3>
                    

                    <small>
                        <p><em>IPvlan</em> es un driver avanzado que nos brindan control sobre las direcciones IPs de los contenedores. También maneja el tag o <a href="https://es.wikipedia.org/wiki/VLAN_Trunking_Protocol" target="_blank">trunk</a> y enrutamiento de las <a href="https://es.wikipedia.org/wiki/VLAN" target="_blank">vlan</a> en capa 2 y 3 respectivamente.</p>
                        <p>Cada contenedor puede tener su propia dirección IP de la subred del host <em>compartiendo la <a href="https://es.wikipedia.org/wiki/Direcci%C3%B3n_MAC" target="_blank">dirección MAC</a></em> del host. Es posible manejar ipvlan en <a href="https://es.wikipedia.org/wiki/Capa_de_enlace_de_datos" target="_blank">L2</a> y <a href="https://es.wikipedia.org/wiki/Capa_de_red" target="_blank">L3</a>.</p>

                    </small>

                    <img src="./img/clase4/ipvlan.png">
                    <small><a href="https://docs.docker.com/engine/network/drivers/ipvlan/" target="_blank">Docker Docs: Driver IPvlan</a></small>




                </section>



                <section id="net_macvlan" data-state="no_footer">
                    <h3>Redes macvlan</h3>

                    <small>
                        <p>Similar a ipvlan, pero la diferencia es que asigna una dirección MAC única a cada contenedor, lo que permite que cada uno se comporte como un dispositivo físico en la red. Es ideal cuando se requiere que los contenedores se integren directamente con la red física existente y sean accesibles desde fuera del host Docker.</p>
                        <p>Tener en cuenta:</p>
                        <ul>
                            <li>El host necesita ser capaz de manegar el <a href="https://es.wikipedia.org/wiki/Modo_promiscuo" target="_blank">modo promiscuo</a> donde una única interfaz física puede tener asignada múltiples direcciones MAC.</li>
                            <li>Si la aplicación puede funcionar en modo <em>bridge</em> es posible que sea mejor solución que macvlan.</li>
                            <li>Puede ser util cuando necesitamos que un contenedor atienda en un puerto ya utilizado por el host.</li>
                        </ul>

                        <p><a href="https://docs.docker.com/engine/network/drivers/macvlan/" target="_blank">Docker Docs: Driver Macvlan</a></p>

                    </small>

         
                </section>

                

                <section id="dockerfile_capas" data-state="no_footer">
                    <h3>Redes Overlay</h3>

                    <small>
                        <p>Permite la creación de redes distribuídas que abarcan múltiples hosts, permitiendo que los contenedores que se ejecutan en diferentes hosts puedan comunicarse entre sí como si estuvieran en la misma red local sin que el sistema operativo del host intervenga en el ruteo. Estas redes se usan en clústeres <a href="https://docs.docker.com/engine/swarm/" target="_blank"><strong>Docker Swarm</strong></a> pero es posible usarlas en instancias de Docker Engine separadas de manera de crear un entorno similar a Docker Swarm.</p>


                        
                    </small>

                    <img src="./img/clase4/overlay.png" width="60%">

                    <p>
                    <small>
                        <a href="https://docs.docker.com/engine/network/drivers/overlay/" target="_blank">Docker Docs: Driver Overlay</a></small>
                    </p>
                    
                </section>


                <section id="ipreguntas2" data-state="no_footer">
                    <h2>Consultas</h2>
                </section>




            </section>


            <section>
				<section id="gestion_network" data-state="customevent" data-transition="slide" data-background-gradient="radial-gradient(#ffffff, #dcffdc)" data-background-size="contain">
					<h3>Gestión de redes Docker</h3>
                    <h4>Comandos básicos</h4>
				</section>

                <section id="gestion_network1" data-state="no_footer">
                    <h3>Gestión de redes Docker</h3>
                    
                    <small>
                        <p>Desde Docker CLI podremos realizar operaciones sobre redes. Con el comando <code>docker network</code> seguido de la instrucción:</p>
                        <ul>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/connect/" target="_blank">connect</a>:</code> Conecta un container a una red.</li>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/create/" target="_blank">create</a>:</code> Crea una red.</li>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/disconnect/" target="_blank">disconnect</a>:</code> Desconecta un container de una red.</li>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/inspect/" target="_blank">inspect</a>:</code> Muestra información detallada de ona o mas redes.</li>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/ls/" target="_blank">ls</a>:</code> Lista las redes</li>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/prune/" target="_blank">prune</a>:</code> Borra todas las redes sin uso.</li>
                            <li><code><a href="https://docs.docker.com/reference/cli/docker/network/rm/" target="_blank">rm</a>:</code> Borra una o mas redes</li>
                        </ul>
                    </small>

                    <small>
                        <p>Para mas detalles ejecutar el comando:</p>
                        <!-- <p><code>docker network COMMAND --help</code></p> -->
                    
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network COMMAND --help
                    </code></pre>

           
    
                </section>


                <section id="network_create" data-state="no_footer">
                    <h3>Crear redes Docker</h3>


                    <small><p>Supongamos que deseamos crear una red modo bridge.</p></small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network create -d bridge mi_red_bridge
                        # O mas simple sin ponerle el driver. Ya que bridge es por defecto.
                        docker network create mi_red_bridge
                    </code></pre>

                    <small><p>Ahora crearemos dos contenedores y conectaremos a esa red.</p></small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker run -dit --name contenedor1 --network mi_red_bridge alpine sh
                        docker run -dit --name contenedor2 --network mi_red_bridge alpine sh
                    </code></pre>

                    <small><p>Ejecute el siguiente comando:</p></small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker exec contenedor1 ping -c 3 contenedor2
                    </code></pre>






                    <small><a href="https://docs.docker.com/reference/cli/docker/network/create/" target="_blank">Docker Docs: docker network create</a></small>



    
                </section>

                <section id="network_ls" data-state="no_footer">

                    <h3>Listar redes Docker</h3>
                    <small><p>Usamos el comando <code>docker network ls</code></p></small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network ls

                        NETWORK ID      NAME                DRIVER      SCOPE
                        cfd3f0bf25fc    bridge              bridge      local
                        abd3e7e42462    host                host        local
                        c1d27506736c    none                null        local
                        c8f2c9e43721    mi_red_bridge       bridge      local

                    </code></pre>

                    <small><p>Observar las columnas. ID, NAME, DRIVER, SCOPE.</p></small>

                        <p><small>
                        <a href="https://docs.docker.com/reference/cli/docker/network/ls/" target="_blank">Docker Docs: docker network ls</a>
                    </small>
                        </p>

                </section>

                <section id="network_rm" data-state="no_footer">
                    <h3>Eliminar redes Docker</h3>
                    <small>
                        <p>Utilizaremos el comando <code>docker network rm NETWORK_ID | NETWORK_NAME </code></p>
                        
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network rm mi_red_bridge

                        nueva_red_bridge # Retorna nombre o hash de la red eliminada
                    </code></pre>
                    <small><a href="https://docs.docker.com/reference/cli/docker/network/rm/" target="_blank">Docker Docs: docker network rm</a></small>
                    <div class="fragment">
                      
                            <h4>Inspeccionar redes</h4>
                            <small>
                                Se usa el comando <code>docker network inspect NETWORK_ID | NETWORK_NAME</code>
                            </small>

                            <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                                docker network inspect bridge
                            </code></pre>
                            <small>¿Qué ha pasado luego de ejecutar ese comando?</small>
                            <p>
                            <small><a href="https://docs.docker.com/reference/cli/docker/network/inspect/" target="_blank">Docker Docs: docker network inspect</a></small>
                            </p>
        
                    </div>





                </section>

                <section id="network_prune" data-state="no_footer">
                    <h3>Eliminar redes Docker sin uso</h3>
                    <small>
                        <p>Utilizaremos el comando <code>docker network prune</code></p>
                        
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network prune

                        WARNING! This will remove all custom networks not
                        used by at least one container.

                        Are you sure you want to continue? [y/N] y
                        Deleted Networks:
                        red_sin_usar1   # Ejemplo de una red creada pero no usada
                        red_sin_usar2   # Ejemplo de una red creada pero no usada

                    </code></pre>

                    <small><a href="https://docs.docker.com/reference/cli/docker/network/prune/" target="_blank">Docker Docs: docker network prune</a></small>


                </section>

                <section id="network_connect" data-state="no_footer">
                    <h3>Conectar a redes Docker</h3>
                    <small>
                        <p>Utilizaremos el comando <code>docker network connect NETWORK CONTAINER</code></p>
                        
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network create red1 # Creamos una red
                        docker run -dit --name container1 alpine sh # Corremos un contenedor
                        # Por defecto estará conectado a la red "bridge"
                        docker network connect red1 container1
                        docker inspect container1 # ¿Ha cambiado de red?
                    </code></pre>

                    <small><a href="https://docs.docker.com/reference/cli/docker/network/connect/" target="_blank">Docker Docs: docker network connect</a></small>


                </section>

                <section id="network_disconnect" data-state="no_footer">
                    <h3>Desconectar de redes Docker</h3>
                    <small>
                        <p>Utilizaremos el comando <code>docker network disconnect NETWORK CONTAINER</code></p>
                        
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker network disconnect red1 container1
                        docker inspect container1 # ¿Se ha desconectado de de red?
                    </code></pre>
                    <small><p>Por defecto volverá a la red bridge.</p></small>
                    <p>

                    <small><a href="https://docs.docker.com/reference/cli/docker/network/disconnect/" target="_blank">Docker Docs: docker network disconnect</a></small>
                    </p>


                </section>
              

                <section id="ipreguntas1" data-state="no_footer">
                    <h2>Consultas</h2>
                </section>

            </section>

            <section>
				<section id="volumenes" data-state="customevent" data-transition="slide" data-background-gradient="radial-gradient(#ffffff, #dcffdc)" data-background-size="contain">
					<h3>Administrar datos en Docker</h3>
                    <h4>Volúmenes y persistencia de datos</h4>
				</section>

                <section id="intro_mounts" data-state="no_footer">
                    <h3>Administrar datos en Docker</h3>
                    <small>
                        <p>En Docker, el manejo del almacenamiento es crucial para persistir datos más allá del ciclo de vida de un contenedor. Dado que los contenedores son efímeros y todos los cambios de 
                            archivos dentro de un contenedor se pierden cuando el contenedor se elimina, Docker ofrece varias opciones para persistir estos datos de manera segura. La Doc los llama de forma abarcativa como <em>mounts</em>.</p>
                    </small>
                    <img src="./img/clase4/persistence.png" width="70%">
                </section>

                <!-- <section id="claves_mounts" data-state="no_footer">
                    <h3>Conceptos clave</h3>
                    <small>
                        <ul>
                            <li><strong>Persistencia de datos:</strong> Los datos almacenados en un contenedor desaparecen cuando el contenedor es eliminado. Docker nos provee mecanismos mediante mounts que permiten que los datos sobrevivan a estos eventos.</li>
                            <li><strong>Compartición de datos:</strong> Los mounts pueden ser compartidos entre múltiples contenedores, facilitando la comunicación y la gestión de datos compartidos.</li>
                            <li><strong>Desacoplamiento de datos:</strong> Los mounts nos permite separar la gestión de datos de la lógica de la aplicación, facilitando el mantenimiento y escalabilidad de las aplicaciones.</li>
                        </ul>
                    </small>
                </section> -->

                <section id="mounts_types" data-state="no_footer">
                    <h3>Tipos de mounts en Docker</h3>
                    <small>
                        <p>Docker soporta varios tipos de mounts, cada uno adecuado para diferentes casos de uso:</p>

                        <ul>
                            <li>Volumes</li>
                            <li>Bind Mounts</li>
                            <li>tmpfs mounts</li>
                        </ul>
                        
                        </small>

                        <p><img src="./img/clase4/mounts.png" width="50%"></p>
                        
                        <small><a href="https://docs.docker.com/engine/storage/" target="_blank">Docker Docs: Manage data in Docker</a></small>

                </section>

                <section id="volumes" data-state="no_footer">
                    <h3>Volumes</h3>
                    <small>
                        <p>Los volúmenes son el mecanismo preferido para conservar los datos generados y utilizados por los contenedores Docker *<a href="https://docs.docker.com/engine/storage/volumes/" target="_blank">[1]</a>.</p>
                        
                    <ul>
                        <li>Son gestionados completamente por Docker</li>
                        <li>Se almacenan en una ubicación específica en el host <code>/var/lib/docker/volumes/</code></li>
                        <li>Pueden ser creados explícitamente o al momento de crear un contenedor.</li>             
                    </ul>
                    

                    </small>
                    <img src="./img/clase4/volumes1.png">
                </section>

                <section id="volumes_ventajas" data-state="no_footer">

                    <h3>Volumes: Ventajas</h3>
                    <small>
                        <ul>
                            <li>Es mas fácil realizar copias de seguridad o migrar volúmenes respecto a otro tipo de mounts.</li>
                            <li>Podemos administrar volúmenes utilizando los comandos de Docker CLI o la API de Docker.</li>
                            <li>Funciona en contenedores Linux y Windows</li>
                            <li>Los volúmenes se pueden compartir de forma más segura entre varios contenedores.</li>
                            <li>Los volumes permiten almacenarse en hosts remotos o proveedores de nube, cifrar el contenido de los volúmenes o agregar otras funciones. (CIFS/Samba, NFS, Block devices, etc)</li>
                            <li>Los volumes en Docker Desktop tiene una muy mejor performance en host Windows y Mac.</li>
    
                        </ul>
                    </small>

                    <p><small><a href="https://docs.docker.com/engine/storage/volumes/" target="_blank">Docker Docs: Volumes</a></small></p>
    
                </section>

                <section id="bind_mounts" data-state="no_footer">

                    <h3>Bind Mounts</h3>
                    <small>
                        <!-- <p></p> -->
                        <ul>
                            <li>Montan un directorio específico del host en un contenedor.</li>
                            <li>Se definen con rutas absolutas (o relativas) del sistema de archivos del host.</li>
                            <li>Ofrecen más flexibilidad pero menos aislamiento, ya que exponen directorios específicos del host al contenedor.</li>
                            <li>Datos fácilmente accesible, pero menor seguridad.</li>
                            <li>No hace falta crear volumenes, simplemente toma los datos del filesystem del host.</li>
    
                        </ul>
                    </small>
                    <img src="./img/clase4/bind_mounts.png">

                    <p><small><a href="https://docs.docker.com/engine/storage/bind-mounts/" target="_blank">Docker Docs: Bind mounts</a></small></p>
    
                </section>

                <section id="tmpfs_mounts" data-state="no_footer">

                    <h3>tmpfs Mounts</h3>
                    <small>
                        <!-- <p></p> -->
                        <ul>
                            <li>Montan un sistema de archivos en memoria.</li>
                            <li>Son útiles para datos temporales que no deben persistir entre reinicios del contenedor.</li>
                        </ul>
                        <p>Limitaciones:</p>
                        <ul>
                            <li>No es posible compartir tmpfs mounts entre contenedores</li>
                            <li>Solo está disponible en host Linux</li>
                            
                        </ul>
                    </small>
                    <img src="./img/clase4/mounts.png" width="50%">

                    <p><small><a href="https://docs.docker.com/engine/storage/tmpfs/" target="_blank">Docker Docs: tmpfs mounts</a></small></p>
    
                </section>

                <section id="ipreguntas3" data-state="no_footer">
                    <h2>Consultas</h2>
                </section>

            </section> <!-- Fin Sección-->

            <section>
				<section id="volumenes" data-state="customevent" data-transition="slide" data-background-gradient="radial-gradient(#ffffff, #dcffdc)" data-background-size="contain">
					<h3>Gestión de volumenes Docker</h3>
                    <h4>Comandos básicos</h4>
				</section>

                <section id="volume_create" data-state="no_footer">
                    <h3>Crear volumenes</h3>
                    <small>
                        <p>Docker nos provee mecanismos desde la Docker CLI para gestionar volúmenes. Vamos a crear un volumen llamado "my_volume".</p>
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker volume create my_volume
                    </code></pre>

                    <h4>Listar volumenes</h4>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker volume ls
                    </code></pre>

                    <small>
                        <p><a href="https://docs.docker.com/reference/cli/docker/volume/create/" target="_blank">Docker Docs: volume create</a></p>
                        <p><a href="https://docs.docker.com/reference/cli/docker/volume/ls/" target="_blank">Docker Docs: volume ls</a></p>
                    </small>


                </section>

                <section id="volume_mount" data-state="no_footer">
                    <h3>Montar un volumen a contenedor</h3>
                    <small>
                        Vamos a montar el volumen <strong>my_volume</strong> en un contenedor.
                    </small>
                        <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                            docker run --rm -it -v my_volume:/home alpine sh
                        </code></pre>
                    <small>
                        Ahora hagamos un cambio en el volumen y salimos del contenedor
                    </small>
                    <pre class="codigo_shadow" data-id="code-animation"><code class="bash codigo-redondo" data-trim>
                        touch /home/mensaje.txt # Creamos un archivo vacío mensaje.txt
                        exit # Salimos del contenedor. Se borrará --rm
                    </code></pre>
                    <small>Ejecutamos un contenedor completamente diferente con el mismo volumen montado.</small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker run --rm -it -v my_volume:/home ubuntu bash
                        ls -l /home
                    </code></pre>

                    <div class="fragment">
                        <small>¿Qué ha ocurrido?<span class="fragment"> Hemos logrado persistir datos y montar el volumen en otro contenedor completamente diferente.</span></small>
                        <small class="fragment"><p><a href="https://docs.docker.com/engine/storage/volumes/#choose-the--v-or---mount-flag" target="_blank">Docker Docs: mount</a></p></small>
                    </div>
                    
                    
                </section>

                <section id="volume_rm" data-state="no_footer">
                    <h3>eliminar volumen</h3>
                    <small>
                        <p>No debe haber ningún contenedor utilizando el volumen. Antes de eliminar el volumen, probablemente tengamos que eliminar los contenedores que lo tengan montado aunque no estén corriendo.</p>
                    </small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker volume rm VOLUME_NAME
                    </code></pre>


                    <p><small><a href="https://docs.docker.com/reference/cli/docker/volume/rm/" target="_blank">Docker Docs: volume rm</a></small></p>

                    <h4>Eliminar volumenes utilizados</h4>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker volume prune
                    </code></pre>

                    <p><small><a href="https://docs.docker.com/reference/cli/docker/volume/prune/" target="_blank">Docker Docs: volume prune</a></small></p>



                </section>

                <section id="volume_inspect" data-state="no_footer">

                    <h3>Inspeccionar volumen</h3>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker volume inspect VOLUME_NAME
                    </code></pre>
                    <small>Info brindada:</small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="json codigo-redondo" data-trim>
                                "CreatedAt": "2024-08-23T09:49:48-03:00",
                                "Driver": "local",
                                "Labels": null,
                                "Mountpoint": "/var/lib/docker/volumes/my_volume/_data",
                                "Name": "my_volume",
                                "Options": null,
                                "Scope": "local"
                    </code></pre>

                    <p><small><a href="https://docs.docker.com/reference/cli/docker/volume/inspect/" target="_blank">Docker Docs: volume inspect</a></small></p>



                </section>

                <section id="docker_cp" data-state="no_footer">

                    <h3>Copiar archivos a contenedores</h3>

                    <small><p>Podemos copiar contenido de nuestro host hacia un contenedor con el comando <code>docker cp [OPTIONS] [PATH] CONTAINER:/[DESTINATION]</code></p></small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker cp config.json contenedor_prueba:/mnt
                    </code></pre>

                    <small><p>O a la inversa, copiar desde el contenedor hacia el host invirtiendo los paths</p></small>

                    <pre class="codigo_shadow" data-id="code-animation"><code class="docker codigo-redondo" data-trim>
                        docker cp contenedor_prueba:/mnt/config.json .
                    </code></pre>

                    <small><p>Esto no es exclusivo de los volúmenes. Se pueden copiar a cualquier path del contenedor por mas que no tenga un volumen montado.</p></small>

                    <p><small><a href="https://docs.docker.com/reference/cli/docker/container/cp/" target="_blank">Docker Docs: container cp</a></small></p>

                </section>

                <section id="ipreguntas4" data-state="no_footer">
                    <h2>Consultas</h2>
                </section>
            </section> <!-- Fin sección-->


           

            <section id="labs_clase" data-state="no_footer">
                <h3>Actividad de práctica:</h3>
                <small>
                <ul>

                    <li><a href="https://github.com/kity-linuxero/docker_410_practicas/blob/v1.2/labs/04-redes_volumes/redes/41-introduccion.md" target="_blank">Lab 4.1</a> Introducción a redes en Docker</li>
                    <li><a href="https://github.com/kity-linuxero/docker_410_practicas/blob/v1.2/labs/04-redes_volumes/redes/42-containers_net.md" target="_blank">Lab 4.2</a> Conexión de Múltiples Contenedores en una Red Bridge</li>
                    <li><a href="https://github.com/kity-linuxero/docker_410_practicas/blob/v1.2/labs/04-redes_volumes/volumes/43-volumenes_docker.md" target="_blank">Lab 4.3</a> Persistencia de datos en Docker</li>
                    <li><a href="https://github.com/kity-linuxero/docker_410_practicas/blob/v1.2/labs/04-redes_volumes/volumes/44-volumenes_bkp.md" target="_blank">Lab 4.4</a> Backup y Migración de Volúmenes</li>
                    
                </ul>

                </small>
                
            
                

            </section>

        </section>

        <section id="fin" data-state="hide_footer" data-transition="slide" data-background-gradient="radial-gradient(#ffffff, #dcffdc)" data-background-size="contain">
			<a href="index.html"><img src="img/logos/idep_logo.png" width="40%" height="40%"></a>
        </section>
						

					
    </div>
</div>

<footer>
    <!-- Logos en el footer -->
    <div id="logos-footer" class="footer">
        <span class="element"><img src="img/logos/cfl_logo.png" class="foot-image"></span>
        <span class="element"><img src="img/logos/IDEPInformaticaLogo.png" class="foot-image-idep-info"></span>
        <span class="element"><img src="img/logos/ate_logo.svg" class="foot-image"></span>
    </div>

    <script type="text/javascript">
        window.addEventListener("load", function() {
    
            revealDiv = document.querySelector("body div.reveal")
            footer = document.getElementById("logos-footer");
            revealDiv.appendChild(footer);
    
        } );
    </script>
</footer>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="plugin/zoom/zoom.js"></script>
<script src="plugin/copycode/copycode.js"></script>


<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/

        // Para eventos personalizados. Indica que está en la presentación

    Reveal.on( 'customevent', function() {
        var element = document.getElementById("logos-footer");
        element.style.display = "table";
        element.style.opacity = "40%";

    } );

    Reveal.on( 'hide_footer', function() {
        var element = document.getElementById("logos-footer");
        element.style.display = "table";
        element.style.opacity = "0%";

    } );

    Reveal.on( 'no_footer', function() {
        var element = document.getElementById("logos-footer");
        //element.style.display = "none";
        // element.style.display = "table";
        element.style.opacity = "15%";
    } );
    Reveal.initialize({
        hash: true,

        copycode: {
        button: "hover",
        display: "icons",
        text: {
            copy: "Copiar",
            copied: "¡Copiado!",
        },
        plaintextonly: true,
        timeout: 1000,
        style: {
            copybg: "gray",
            copiedbg: "green",
            copycolor: "black",
            copiedcolor: "white",
            copyborder: "",
            copiedborder: "",
            scale: 1,
            offset: 0,
            radius: 0.2
        },
        tooltip: true,
        iconsvg: {
            copy: '',
            copied: ''
        },
        cssautoload: true,
        csspath: "",
        clipboardjspath: ""
        },

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom, CopyCode ]
    });
</script>

</body>
</html>